\begin{algorithm}[h]
\begin{algorithmic}[0]
\Statex
\State\textbf{\hspace{-7pt}Global space:} $P$ - projection tree; $V$ - vertices; $T$ - triangles
\State\textbf{\hspace{-7pt}Input:} $p$ - point to be processed; $q$ - next point to be processed; $S$ - saved vertices
\State\textbf{\hspace{-7pt}Output:} none
\end{algorithmic}
\begin{algorithmic}[1]
\vspace{3pt}
\Function{facet}{$p$, $q$, $S$}
\State $P.$\Call{insert}{$p$} \raisedrule\Comment{Insert $p$ in the projection tree}
\State $c \leftarrow P.$\Call{pred}{$p$} \raisedrule\Comment{Get $p$'s predecessor in the projection tree}
\If{$c_3 \leq p_3$} \raisedrule\Comment{If $p$ is not optimal}
\State $P.$\Call{remove}{$p$} \raisedrule\Comment{Remove $p$ from the tree}
\State \Return \raisedrule\Comment{Exit function}
\EndIf
\If{$S \neq \emptyset$} \raisedrule\Comment{Special case (facet sharing)}
\State $v1 \leftarrow S_1$ \raisedrule\Comment{Recover vertex $v1$ (was saved as $v3$)}
\Else \raisedrule\Comment{General case}
\If{$P.$\Call{succ}{$p$}$_2 = p_2$} \raisedrule\Comment{If $p$'s successor is partially dominated by $p$}
\State $c \leftarrow P.$\Call{succ}{$p$} \raisedrule\Comment{Edge intersects the successor and not the predecessor}
\State $P.$\Call{remove}{$c$} \raisedrule\Comment{Remove $p$'s successor from the tree}
\EndIf
\State $v1 \leftarrow V.$\Call{create}{$p_1$, $p_2$, $c_3$} \raisedrule\Comment{Define vertex $v1$}
\EndIf
\Loop \raisedrule\Comment{Iterate through $p$'s successors}
\State $c \leftarrow P.$\Call{succ}{$p$} \raisedrule\Comment{Get $p$'s successor in the projection tree}
\If{$S \neq \emptyset$} \raisedrule\Comment{Special case (facet sharing)}
\State $v2 \leftarrow S_2$ \raisedrule\Comment{Recover vertex $v2$ (was saved as $v2$)}
\State $S \leftarrow \emptyset$ \raisedrule\Comment{Clear saved vertices}
\Else \raisedrule\Comment{General case}
\State $v2 \leftarrow V.$\Call{create}{$p_1$, $c_2$, $v1_3$} \raisedrule\Comment{Define vertex $v2$}
\EndIf
\If{$c_3 \leq p_3$} \raisedrule\Comment{If $p$'s successor is not fully dominated by $p$}
\State \textbf{break} \raisedrule\Comment{Break cycle (edge intersection)}
\EndIf
\State $v3 \leftarrow V.$\Call{create}{$p_1$, $c_2$, $c_3$} \raisedrule\Comment{Define vertex $v3$}
\State $T.$\Call{create}{$v1$, $p$, $v3$} \raisedrule\Comment{Create triangle [$v1$-$p$-$v3$]}
\State $T.$\Call{create}{$v1$, $v2$, $v3$} \raisedrule\Comment{Create triangle [$v1$-$v2$-$v3$]}
\State $P.$\Call{remove}{$c$} \raisedrule\Comment{Remove $p$'s successor from the tree (it is fully dominated)}
\State $v1 \leftarrow v3$ \raisedrule\Comment{Vertex $v3$ becomes the new vertex $v1$}
\EndLoop
\If{$q \neq \emptyset$ \textbf{and} $q_1 = p_1$ \textbf{and} $q_2 < c_2$ \textbf{and} $q_3 < p_3$} \raisedrule\Comment{Special case (facet sharing)}
\State $v3 \leftarrow V.$\Call{create}{$p_1$, $q_2$, $p_3$} \raisedrule\Comment{Define vertex $v3$ (intersection of $p$ and $q$)}
\State $S \leftarrow \{v3, v2\}$ \raisedrule\Comment{Save vertices $v3$ and $v2$ (will become $v1$ and $v2$)}
\Else \raisedrule\Comment{General case}
\State $v3 \leftarrow V.$\Call{create}{$p_1$, $c_2$, $p_3$} \raisedrule\Comment{Define vertex $v3$}
\If{$p_3 = c_3$} \raisedrule\Comment{If $p$'s successor is partially dominated by $p$}
\State $P.$\Call{remove}{$c$} \raisedrule\Comment{Remove $p$'s successor from the tree}
\EndIf
\EndIf
\State $T.$\Call{create}{$v1$, $p$, $v3$} \raisedrule\Comment{Create triangle [$v1$-$p$-$v3$]}
\State $T.$\Call{create}{$v1$, $v2$, $v3$} \raisedrule\Comment{Create triangle [$v1$-$v2$-$v3$]}
\EndFunction
\end{algorithmic}
\caption{Facet computation}
\label{alg:facet_computation}
\algrule[1pt]
\small The projection tree sorts its elements in the following order: $x_2,x_3,x_1$.\\Function $P$.\textsc{insert}($a$) inserts point $a$ into the projection tree ($P$) and function $P$.\textsc{remove}($a$) removes point $a$ from the tree.\\Function $P$.\textsc{pred}($a$) returns the predecessor of $a$ in the tree, and function $P$.\textsc{succ}($a$) returns the successor of $a$ in the tree.\\Function $V$.\textsc{create}($a,b,c$) creates a vertex with the coordinate values of $a$, $b$ and $c$. In the case that there is an existing vertex with the same values, the function returns the existing vertex instead. One can efficiently achieve this by using a hash table. The hash function is defined as \textsc{hash}$(a,b,c) = a.p_1$ \textbf{xor} $b.p_2$ \textbf{xor} $c.p_3$, where $p_1$, $p_2$ and $p_3$ are large prime numbers: 73856093, 19349663 and 83492791, respectively \cite{teschner_hash}.\\Function $T$.\textsc{create}($a,b,c$) creates a triangle formed by the points/vertices $a$, $b$ and $c$.
\end{algorithm}