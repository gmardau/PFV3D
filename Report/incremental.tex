\section{Incremental approach}

\paragraph{Methodology} The objective of an incremental approach to the frontier computation is to be able to perform modifications --- adding or removing points --- without having to recalculate every facet. The implementation consists of knowing whether to (re)compute the facets or to just update the projection tree --- much like the optima algorithm --- for each point of the set for each dimensional sweep. Also, whenever the points that have been scheduled for addition and removal are finished processing, the algorithm can be terminated, since the rest of the facets will remain intact.
Another optimisation to be considered is whenever the points scheduled for removal are at the end of the sorting list for a particular dimension. If this is the case, it would be enough to remove the facets generated by these points and translate the vertices from the old limits of the frontier to the new limits. Likewise, whenever the frontier's span increases --- addition of points beyond the limits ---, the vertices at the limits can be translated to the new limits, possibly avoiding some facet recalculation.

\paragraph{Points scheduled for addition and removal} Between frontier computations, any number of points can be scheduled for addition or removal. The incremental approach recalculates facets only when these points influence the computation, i.e.\ when they are present in the projection tree. When iterating through the points' predecessors and successors in the projection tree, the points scheduled for addition are treated as regular points, while the ones scheduled for removal are ignored. The latter are still verified and removed from the projection tree when dominated.

\paragraph{Advantages and disadvantages} The main \textit{advantage} of an incremental approach is that not every facet needs to be recalculated, reducing not only processing time but also memory management. Still, the projection tree needs to be updated. In the worst case scenario, one has to process every single point, inserting them in the projection tree, only to compute the facets generated by a single point at the end. However, it is still a better choice than to recalculate the whole frontier from scratch. The main \textit{disadvantage} is memory consumption. In order to efficiently add and remove points from the frontier, it is advisable to store the set of points in a order-based structure, like a binary tree, so to avoid sorting the entire set whenever the frontier is to be updated. Note that three structures are necessary, one for each dimension. Furthermore, if one desires to perform the optimisations described at the end of the paragraph ``Methodology'', the same needs to be done for the vertices, so that those at the limits are easily accessible.

\paragraph{Algorithm conditions:}\ \\[2pt]The dimensional sweep can be terminated when none of the following conditions proves true:
\begin{itemize}
\item Projection tree contains points scheduled for addition and/or removal
\item Points scheduled to be added and/or removed are still to be processed
\item Facet sharing (vertices have been saved)
\item Facet sharing break
\end{itemize}
When deciding whether to (re)compute the facet (1) or to just insert the point in the projection tree (2), the following verifications must be performed (in this order):
\begin{itemize}
\item Point is scheduled for removal $\rightarrow$ (2)
\item Point is scheduled for addition, or ...
\\[2pt] Projection tree contains points scheduled for addition and/or removal, or ...
\\[2pt] Point has the same sweep dimension value as the next point scheduled to be added or removed, or ...
\\[2pt] Facet sharing (vertices have been saved), or ...
\\[2pt] Facet sharing break $\rightarrow$ (1)
\item Otherwise $\rightarrow$ (2)
\end{itemize}

\paragraph{Special case: facet sharing break} Due to the incremental nature of the method, a new special case must be considered --- mentioned above as \textit{facet sharing break}. This occurs when the projection of a new point $c$ dominates or is equal to the intersection of two already existing points, $p$ and $q$, that share a facet. When this happens, the facets of $p$ and $q$ need to be recalculated. However, since they no longer share the same facet and $c$ is partially dominated by $p$, and therefore removed from the projection tree, there would be no reason to recompute the facets of $q$. To solve this problem, a verification at the end of the facet computation routine is necessary, activating a flag variable to force the recalculation of the facets of $q$. The verification --- placed between lines 33 and 34 of Algorithm \ref{alg:facet_computation} --- is as follows:
\begin{align*}
c.\textsc{state}() = 1\ \textbf{and}\ q_1 = p_1\ \textbf{and}\ p.\textsc{state}() = 0\ \textbf{and}\ q.\textsc{state}() = 0
\end{align*}
where \textsc{state}() returns $1$ if the respective point is scheduled for addition, $-1$ if it is scheduled for removal, and $0$ otherwise.

\paragraph{Complexity} Neither the time nor the space complexities of the algorithm are changed by the incremental approach. The only thing to note is the increase in memory usage, already described in the paragraph ``Advantages and disadvantages''.